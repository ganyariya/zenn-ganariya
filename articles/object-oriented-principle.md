---
title: "パッケージ設計の原則とSOLID原則についてまとめる"
emoji: "🕌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["オブジェクト指向", "SOLID"]
published: true
---

# はじめに

https://gihyo.jp/book/2022/978-4-297-13234-7

先日、前から気になっていた `ちょうぜつソフトウェア設計入門` を読み終えました。

ソフトウェアを設計するうえで、知っておくとよい知識を網羅的にまとめている良書でした。
とくにパッケージ設計の原則と SOLID 原則については、一部知ってはいるものの他は大まかな内容しか知らないという状態だったので勉強になりました。

今回は、 2 章と 5 章に出てくるパッケージ設計の原則と SOLID 原則についてまとめようと思います。

# パッケージ設計の原則

エンジニアが設計ならびに開発していくうえで、ありとあらゆるコードを自分で書くことは不可能です。
たとえば、ウェブアプリ開発の場合は以下のように機能ごとに何かしらのパッケージを利用すると思います。

- Web Framework: Express
- 仮想 DOM: React
- ORM: Prisma
- Build: Webpack

このように、ある一機能を提供するためにそれぞれパッケージが作成されています。
そして、利用者は自分が利用したいパッケージを好きな数だけ選定し、存在しない場合は社内でオリジナルのパッケージを開発します。

これら `機能ごとにまとめられた再利用されたコード` が `パッケージ` であり、このパッケージをどのような基準でまとめていくのかがパッケージ設計の原則です。

`設計の原則` とあるように、パッケージ利用者が考えるべき原則というよりは、パッケージを提供する開発者側の原則です。

## Reuse-Release Equivalent Principle (REP)

>リリースされたものだけを再利用しなさい。
>再利用させたいのであればリリースしなさい。

上記を表しているものが REP です。

何かしらコードを書いていて、それをユーザに利用してもらいたいのであればリリースしてください。
ユーザはリリースされたパッケージのコードをすべて利用することになります、というものです。

https://www.npmjs.com/package/react

たとえば、仮に自分が React の開発者だった場合を考えます。
このとき、新しい `useXXX` 機能を提供したい場合は、それを含めたパッケージとして新たなバージョン (`19.x.x` など)を作成する必要があります。
新たなバージョンを切らない限り、ユーザは安心してパッケージを利用できません。

どのようにパッケージ（再利用の単位）をきめるかどうかは、`Common Reuse Principle` と `Common Closure Principle` を参考にします。

## Common Reuse Principle (CRP)

> ユーザはパッケージ内にあるコードをすべて利用するか、もしくはすべて利用しないかを選択するしかない。
> そのためパッケージが一つの責務のみ持つようになるまで、パッケージを分けるべきである。

パッケージに含まれるコードはすべて利用されるというものです。
ここで、`利用される` という表現は分かりづらいので、`ユーザはパッケージのコードをすべて利用するしかない` と捉えるとよいかと思います。

React を v16.x.x を利用している状態で、 v18.x.x へアップデートしたい場合を考えます。
このとき、`v18.x.x の Suspense のみ利用してそれ以外は v.16.x.x を利用する` ということはできません。

v18.x.x の Suspense を利用したい場合、 v18.x.x から deprecated になるコードは削除し、すべて v18.x.x に移行する必要があります。
また、 React Router のような React を利用する外部パッケージライブラリについても v18.x.x で動作するようにうまく調整する必要があります。
（メンテナンスされたおらず、v16.x.x の React でしか利用できないパッケージも多く、仕方なく `--legacy-peer-deps` を使うことも多々ありますね。）

このように、ユーザはパッケージにあるコードをすべて利用する（バージョンをうまく選択する）必要があります。
よって、開発者側は `パッケージがある 1 つの債務（機能）を提供する` コードのみを 1 つのパッケージとして提供するべきです。

たとえば、React の場合は、 UI を仮想 DOM として提供することだけに専念したものになっています。
ルーティングについては React Router、サーバ側の DOM レンダリングについては react-dom など機能ごとにそれぞれパッケージ分割されています。

できるだけパッケージは小さな 1 つの機能のみを提供することを目指し、その機能のみを提供できるようになるまで小さなパッケージに分割しましょう。

## Common Closure Principle (CCP)

> ひとつの変更が必要なとき、できるだけ一つのパッケージのみ交換すればよい形にする
> よって、 1 つのパッケージに 1 つの責務（機能）を提供するコードのみをまとめあげる。

オブジェクト指向における SOLID 原則の単一責任の原則に近い原則となっています。

パッケージ内のある 1 箇所を変更することによって、他のパッケージも変更ならびに交換する必要がでてきた場合、パッケージ分割がうまくできていないといえます。
パッケージには、ある 1 つだけの責務を持つように、関連する機能のコードのみをまとめあげましょう。

## 凝集度と結合度

<!-- textlint-disable -->

Common Reuse Principle（分けるべきものは分ける） と Common Closure Principle（まとめるべきものはまとめる） 両方を守ることによって

- 関係ないコードは他のパッケージに
- 関係あるコードは同じパッケージに

分割できます。

<!-- textlint-enable -->

これによって、パッケージ内の凝縮度が高くなり、パッケージごとの結合度が小さくなります。

## Acyclic Dependencies Principle (ADP)

> パッケージの依存が循環してはならない。

ADP はパッケージ間の関係性を示した原則です。

パッケージ同士に循環依存が発生するとすべてのパッケージを利用する必要があり、パッケージを 1 つだけ交換する、ということができません。
循環依存が発生するような強い結びつきについては、異なるパッケージにするのではなく同じパッケージにまとめあげるべきです。

たとえば、 Go 言語においては異なるパッケージが互いに循環参照になるとコンパイルエラーになります。
しかし、同じパッケージ内であれば struct interface が互いに循環参照しても問題ありません。

## Stable Dependencies Principle (SDP)

> パッケージの依存は常により安定したパッケージに向くべきである。

より変更が少ない、安定したパッケージに対して依存するようにするべき、というものです。

React Hook Form ライブラリは、より安定した React ライブラリに依存します。
そして、 React ライブラリはより安定した JSX の仕様ならびに JavaScript の仕様に依存します。

Clean Architecture の Entity Business Rule と同様に、不安定なものが安定なものに依存するべきという原則です。

## Stable Abstractions Principle

> 安定度が高いパッケージであるためには抽象度が高い必要がある。
> 安定度の引くパッケージは抽象度が低く、具体的でよい。

オブジェクト指向においては `抽象` であるほど安定度が高いといえます。
interface はオブジェクト間の API のみを取り決めており、具体的な実装はありません。

interface を実装したクラスやメソッドは、仕様の変更によって実装内容も変更されます。

PHP の PSR という共通仕様は抽象度が非常に高いといえます。
PSR-7 では HTTP Message が満たすべき interface のみが定められており、具体的な実装は一切ありません。

具体的な実装は Slim や Falcon など、各サードパーティフレームワークに委ねられています。

https://www.php-fig.org/psr/psr-7/

このように、抽象であればあるほど変更可能性は低く、変更に開けています。
このような抽象なパッケージは安定度が高いため、 SDP もふまえると、できるだけ抽象なパッケージに依存するべきともいえます。
