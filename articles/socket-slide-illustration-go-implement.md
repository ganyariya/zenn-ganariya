---
title: "ソケット通信の仕組みをスライド図解と Go 実装で説明する"
emoji: "🔖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["socket", "tcp", "socket", "go"]
published: true
---

# はじめに

先日、 `Linuxで動かしながら学ぶTCP/IPネットワーク入門` を読了ならびに実装しました。
こちらの本は下記に関して内容がわかりやすく記述されており、`入門` としてとても良い本でした。

- データリンク層におけるイーサネットを通るフレームの挙動
- TCP/IP の挙動
- アプリケーション層のプロトコル (HTTP / DHCP / NAT)
- socket 通信

https://www.amazon.co.jp/Linux%E3%81%A7%E5%8B%95%E3%81%8B%E3%81%97%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6TCP-IP%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E5%85%A5%E9%96%80-%E3%82%82%E3%81%BF%E3%81%98%E3%81%82%E3%82%81-ebook/dp/B085BG8CH5

https://zenn.dev/ganariya/scraps/bb69305adef042

しかし、上記の本を進める中でソケット通信の内容が詳細には分からず、だいぶもどかしい気持ちになってしまいました。
分からなかった部分としては以下のようなものです。

- そもそも socket とはなにか
- Server で accept() したときに新しい socket を生成しているようだがこれはなにか
  - Server で最初に作成した `socket()` と同じものなのか
  - それともクライアント用の socket なのか
- Server の port 番号（例: 80）は固定でよいのか
  - 複数のクライアントから通信がくるため、 Server port 80 にやってきた通信がどの client のものかの判別方法
- pid port fd の違いについて

これら分からない部分が分からないままなのは嫌だったため、 Go における `Server: 1 Client: 多` ソケット通信プログラムを実装しました。
また、 Go のソケット通信の内部で何が行われているのかを大まかにコードリーディングしました。

<!-- textlint-disable -->
時間の経過とともに内容を忘れるであろう将来の自分、ならびにソケット通信の挙動がいまいち分からない方に向けて、今回学んだ内容をスライド図解とともにまとめます。
スライドは以下のリンクです。
<!-- textlint-enable -->

https://docs.google.com/presentation/d/105qsTIXiZYoUKMhXeHqqM4dQf3pqDckdVoZw0w3vnyE/edit

## 対象読者

<!-- textlint-disable -->
- 記憶が曖昧になった将来の自分
- ソケット通信の挙動がいまいち分からない方
<!-- textlint-enable -->

## 扱う内容・扱わない内容

### 扱う内容

- 下記に関する図解説明
  - ファイルディスクリプタ
  - fork / pipe
  - socket
- Go におけるクライアント複数に対する Server の Echo 実装

上記に関して、その技術を使うことによる嬉しさならびに全体的な動きをスライド図解しながらまとめようと思います。

わかりやすさを優先して書く、ならびに筆者の知識が間違っている可能性から、内容の不備が存在しえます。
ぜひコメントをいただければと思います（修正させていただきます）。

### 扱わない内容

- bind listen accept などの C 言語におけるソケット通信の流れ
  - Go はこのあたりを意識しなくていいようにしてくれています
- Family Type `AF_UNIX`
  - 同じマシン内の異なるプロセスがソケットで通信する場合の `AF_UNIX` は取り扱っていません
- 低レイヤ socket の実装
- 低レイヤ TCP / IP の実装

今度まとまった空き時間ができたら [KLab さんのスライド](https://drive.google.com/drive/folders/1k2vymbC3vUk5CTJbay4LLEdZ9HemIpZe) を参考にしながら、自分でプロトコルを実装してみたいですね。

# ソケット通信を利用する理由

はじめに、どうしてソケット通信を利用するのかについて説明します。
このとき、ファイルディスクリプタや pipe が出てきます。
これらについては、次の節で説明するため、ここではそういうものがあるのだなという認識で大丈夫です。

![](https://storage.googleapis.com/zenn-user-upload/411b29dbbfb9-20230513.png)

そもそも前提として、自プロセスが何かしらの情報を取得・送信したい場合、相手のプロセスと通信する必要があります。
たとえば、 Chrome から `zenn.dev` のサイトにアクセスして zenn のページを閲覧したい場合は、以下のプロセスが HTML 等をやり取りする必要があります。

- Chrome のプロセス
  - HTML CSS JavaScript のファイルをくださいと要求する
- zenn.dev のサーバプロセス
  - 上記のファイルを送信する

このようにプロセス間でなにかしらのメッセージ（バイト列）を通信で送信したい場合、相手のプロセスの所在が認識できなければいけません。

ここで、`親子プロセス` や明示的なコマンドパイプ（`ls | grep Documents`）の場合は、 `pipe` という UNIX 系通信機能を利用すればプロセス間で通信できます。
このように通信できるのは、2 つのプロセスが互いに簡単に相手のプロセス番号 pid を知ることができるためです。
シェルスクリプトを書くときなど、我々は明示的に `A | B | C ...` のように通信先のプロセスを指定していますね。

しかし、異なるマシン（異なるインターネット）であればどうでしょうか。
zenn.dev のサーバに関するプロセスの番号がいくつなのかは Chrome にはわかりません。
つまり** zenn.dev のどのプロセスと通信してよいのかは Client である Chrome にはわからないのです。**
このままでは Chrome と zenn.dev が情報をやりとりできません。

そこで、 Socket API を利用します。
Socket API は **`同一または異なるマシンにまたがる` 2 つのプロセスが、相手を所在を認識することなく通信するための API** です。
**ネットワーク層における `IP Address`**、ならびに**トランスポート層における `port 番号`** を組み合わせたものをソケットの通信先（アドレス）として認識します。

これによって、相手のプロセスの詳細はわからないままで、相手のアドレス（IP Address + port）に向かって socket を介して通信できます。
各プロセスは port にやってくる通信の内容を socket を通じて読み取れるため、プロセス同士が `間接的に` 通信できます。
（ポート番号や UNIX ドメインソケットを利用することで、プロセスは異なるマシンの相手の所在を知ることなく **間接的に** 通信しています、という `間接的に` です。）

## ファイルディスクリプタの利用

pipe ならびに Socket API どちらにおいても、内部ではファイルならびにファイルディスクリプタを利用しています。
そのため、Socket API の挙動について説明する前に、事前知識としてファイル・ファイルディスクリプタ・pipe からまとめようと思います。

# 事前知識: ファイルディスクリプタ pipe

## ファイル

![](https://storage.googleapis.com/zenn-user-upload/c1ceb3a69c6a-20230513.png)

UNIX / Linux ではあらゆるものを `ファイル` として扱っています。
`master_data.json` のようなテキストファイルだけでなく、キーボードや仮想端末もファイルとして扱われます。

統一的にファイルとして扱うことによって、プログラムからはファイルに対する read / write を呼び出すだけで情報を読み書きできます。

プロセスがファイルを開くと、該当のファイルを認識するための ID として `ファイルディスクリプタ` (fd) という整数が OS Kernel から与えられます。
このファイルディスクリプタは**プロセスごとに独立して** 0, 1, 2, ... と続いてきます。
<!-- textlint-disable -->
注意として、プロセス A が 0, 1, 2, 3, 4 まで開いたからといって、プロセス B の fd が 5 から始まるわけではありません。
<!-- textlint-enable -->

![](https://storage.googleapis.com/zenn-user-upload/c510e8bdf8ab-20230513.png)

たとえば、上記の画像のようにターミナルで `zsh` シェルを起動したとします。
このとき、ターミナルには仮想端末 `/dev/ttys013` が紐付けられています。

そして、 zsh のプロセスが開いているファイルディスクリプタを `lsof` コマンドで確認してみると、各 fd は `/dev/ttys013` ファイルをシンボリックリンクで指しています。

- fd: 0 標準入力 `/dev/ttys013`
- fd: 1 標準出力 `/dev/ttys013`
- fd: 2 標準エラー出力 `/dev/ttys013`

ゆえに、 Alacritty のようなターミナルでシェルを起動すると、そのターミナルに文字を入力・表示できるようになっているのですね。

## fork

![](https://storage.googleapis.com/zenn-user-upload/16b13517d6c6-20230513.png)

fork はソケット通信のために必須ではないのですが、 pipe の説明であったほうがよいので記述します。

親プロセスから子プロセスを生成する、`fork` すると、親プロセスの環境変数や `fd` が子プロセスへ継承されます。
これによって、デフォルトでは子プロセスは親プロセスと同じ標準入出力を扱えます。

fork の具体的なイメージについて、上記の画像の例で説明します。
ターミナルで `sleep 100 & > a.txt` と入力した場合を考えます。

zsh プロセスから sleep プロセスが fork されます。
このとき、 zsh の fd が sleep に継承され、標準入出力の向き先が `/dev/ttys013` となっています。
ただし、 `> a.txt` として標準出力の向き先をリダイレクトで変更しているため、 `fd: 1` のみ `a.txt` を指すようになっています。

## pipe

![](https://storage.googleapis.com/zenn-user-upload/409fe52d522f-20230513.png)

`ls | grep` のように、ユーザ自身で 2 つのプロセスの通信先を指定できるのであればソケット通信でなくパイプを利用すればよいです。
親子プロセスの通信においても `pipe()` システムコールを呼び出せば、パイプを利用して情報をやりとりできます。

パイプを利用すると、ファイルディスクリプタの向き先が接続されることによって通信を行えます。

上記の画像の例では `sleep 100 | sleep 200 > a.txt &` を実行しています。
各 sleep コマンドは zsh から fork されているため、デフォルトでは zsh と同じ標準入出力を fd が指します。

しかし、 `|` でパイプを実行しているため、`sleep 100` の `fd:1` の向き先が `sleep 200` の `fd:0` となっています。
そのため、 `sleep 100` の出力はそのまま `sleep 200` の標準入力に流れていきます。（sleep のため、なにも影響を及ぼさないですが...）

このように、ユーザ自身で 2 つのプロセスの通信先を指定できる場合は pipe でプロセス同士が通信できます。

問題は同一マシンだが相手のプロセスが明示的に指定しづらい場合や、異なるマシン（ネットワーク）の場合です。
この場合はソケット通信を利用することでプロセス同士が `間接的に` 通信できます。
